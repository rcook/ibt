#!/usr/bin/env python

###############################################################################
#
# IBT: The Isolated Build Tool
# Copyright (C) 2016, Richard Cook. All rights reserved.
#
# Simple wrappers around Docker etc. for fully isolated build environments
#
###############################################################################

import hashlib
import os
import shutil
import subprocess
import sys
import yaml

CONTAINER_PROJECT_DIR = "/ibt"
CONTAINER_DOT_DIR = os.path.join(CONTAINER_PROJECT_DIR, ".ibt")
SCRIPT_FILE_NAME = "temp.sh"

def uid_gid(dir):
  proc = subprocess.Popen(
    ["stat", "-c", "%u:%g", dir],
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE)
  (out, error) = proc.communicate()
  if proc.returncode != 0:
    raise RuntimeError("stat command failed: {}".format(error))

  return out.strip().split(":")

def docker_image_exists(image_id):
  proc = subprocess.Popen(
    ["docker", "inspect", image_id],
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE)
  proc.communicate()
  return proc.returncode == 0

def docker_image_build(image_id, project_dir):
  if docker_image_exists(image_id):
    print("Docker image {} already built".format(image_id))
  else:
    print("Building Docker image {}".format(image_id))
    proc = subprocess.Popen(
      ["docker", "build", "-t", image_id, project_dir],
      stdout=subprocess.PIPE,
      stderr=subprocess.PIPE)
    (_, error) = proc.communicate()
    if proc.returncode != 0:
      raise RuntimeError("docker build command failed: {}".format(error))

def docker_image_remove(image_id):
  if docker_image_exists(image_id):
    print("Destroying Docker image {}".format(image_id))
    proc = subprocess.Popen(
      ["docker", "rmi", image_id],
      stdout=subprocess.PIPE,
      stderr=subprocess.PIPE)
    (_, error) = proc.communicate()
    if proc.returncode != 0:
      raise RuntimeError("docker rmi command failed: {}".format(error))
  else:
    print("No Docker image {} to destroy".format(image_id))

def make_run_command(image_id, project_dir, container_working_dir, args=None):
  (uid, gid) = uid_gid(project_dir)
  front = [
    "docker",
    "run",
    "-w",
    container_working_dir,
    "-u",
    "{}:{}".format(uid, gid),
    "-v",
    "{}:{}".format(project_dir, CONTAINER_PROJECT_DIR),
    "--rm",
  ]
  back = [
    image_id
  ]

  return front + back if args is None else front + args + back

  if args is None:
    re
  return front + args + back

def docker_run(image_id, project_dir, container_working_dir, container_run_path):
  command = make_run_command(image_id, project_dir, container_working_dir) + [
    "/bin/sh",
    container_run_path
  ]
  subprocess.check_call(command)
    
class Context(object):
  def __init__(self, dir):
    self._dir = dir
    self._ibt_file_name = self._find_ibt_file(self._dir)
    if self._ibt_file_name is None:
      raise RuntimeError("ibt command run outside project")

    self._project_id = hashlib.md5(self._ibt_file_name).hexdigest()
    self._image_id = "ibt-{}-image".format(self._project_id)
    self._container_id = "ibt-{}-container".format(self._project_id)
    self._project_dir = os.path.dirname(self._ibt_file_name)
    self._dot_dir = os.path.join(self._project_dir, ".ibt")

  @property
  def ibt_file_name(self): return self._ibt_file_name

  @property
  def dir(self): return self._dir

  @property
  def project_id(self): return self._project_id

  @property
  def image_id(self): return self._image_id

  @property
  def container_id(self): return self._container_id

  @property
  def project_dir(self): return self._project_dir

  @property
  def dot_dir(self): return self._dot_dir

  @staticmethod
  def _find_ibt_file(dir):
    file_name = os.path.join(dir, "Ibtfile")
    if os.path.isfile(file_name):
      return file_name
    parent_dir = os.path.dirname(dir)
    return None if parent_dir == dir else Context._find_ibt_file(parent_dir)

def do_up(ctx, args):
  if len(args) > 0:
    raise RuntimeError("up takes no arguments")

  with open(ctx.ibt_file_name, "rt") as f:
    settings = yaml.load(f)

  if not os.path.isdir(ctx.dot_dir):
    os.makedirs(ctx.dot_dir)

  with open(os.path.join(ctx.dot_dir, ".dockerignore"), "wt") as f:
    f.write("*\n")

  (uid, gid) = uid_gid(ctx.project_dir)

  with open(os.path.join(ctx.dot_dir, "Dockerfile"), "wt") as f:
    f.write("FROM {}\n".format(settings["docker-image"]))
    f.write("RUN groupadd -g {} ibt\n".format(gid))
    f.write("RUN useradd -u {} -g {} ibt\n".format(uid, gid))

  docker_image_build(ctx.image_id, ctx.dot_dir)

def do_destroy(ctx, args):
  if len(args) > 0:
    raise RuntimeError("destroy takes no arguments")

  docker_image_remove(ctx.image_id)

def do_run(ctx, args):
  if len(args) == 0:
    raise RuntimeError("run takes one or more arguments")

  if not docker_image_exists(ctx.image_id):
    raise RuntimeError("Project has not been upped")

  rel_dir = os.path.relpath(ctx.dir, ctx.project_dir)
  container_working_dir = os.path.join(CONTAINER_PROJECT_DIR, rel_dir)

  local_run_path = os.path.join(ctx.dot_dir, SCRIPT_FILE_NAME)
  container_run_path = os.path.join(CONTAINER_DOT_DIR, SCRIPT_FILE_NAME)

  with open(local_run_path, "wt") as f:
    f.write("#!/bin/sh\n")
    f.write(" ".join(args) + "\n")

  docker_run(
    ctx.image_id,
    ctx.project_dir,
    container_working_dir,
    container_run_path)

def do_script(ctx, args):
  if len(args) != 1:
    raise RuntimeError("script takes one argument")

  if not docker_image_exists(ctx.image_id):
    raise RuntimeError("Project has not been upped")

  rel_dir = os.path.relpath(ctx.dir, ctx.project_dir)
  container_working_dir = os.path.join(CONTAINER_PROJECT_DIR, rel_dir)

  local_run_path = os.path.join(ctx.dot_dir, SCRIPT_FILE_NAME)
  container_run_path = os.path.join(CONTAINER_DOT_DIR, SCRIPT_FILE_NAME)

  shutil.copyfile(args[0], os.path.join(ctx.dot_dir, "script"))
  container_script_path = os.path.join(CONTAINER_DOT_DIR, "script")

  with open(local_run_path, "wt") as f:
    f.write("#!/bin/sh\n")
    f.write("chmod +x {}\n".format(container_script_path))
    f.write(container_script_path + "\n")

  docker_run(
    ctx.image_id,
    ctx.project_dir,
    container_working_dir,
    container_run_path)

def do_shell(ctx, args):
  if len(args) != 0:
    raise RuntimeError("shell takes no arguments")

  if not docker_image_exists(ctx.image_id):
    raise RuntimeError("Project has not been upped")

  rel_dir = os.path.relpath(ctx.dir, ctx.project_dir)
  container_working_dir = os.path.join(CONTAINER_PROJECT_DIR, rel_dir)

  command = make_run_command(
    ctx.image_id,
    ctx.project_dir,
    container_working_dir,
    ["-it"])
  subprocess.check_call(command)

def do_status(ctx, args):
  if len(args) > 0:
    raise RuntimeError("status takes no arguments")

  (uid, gid) = uid_gid(ctx.project_dir)

  print("Project information:")
  print("  Project directory:   {}".format(ctx.project_dir))
  print("  Working directory:   {}".format(ctx.dir))
  print("  Project ID:          {}".format(ctx.project_id))
  print("  Configuration file:  {}".format(ctx.ibt_file_name))
  print("  Temporary directory: {}".format(ctx.dot_dir))
  print("User information:")
  print("  UID:                 {}".format(uid))
  print("  GID:                 {}".format(gid))
  print("Docker information:")
  print("  Docker image ID:     {}".format(ctx.image_id))
  print("  Docker container ID: {}".format(ctx.container_id))

def main(dir, args):
  args.pop(0)
  if len(args) < 1:
    print("Commands:\n"
        "  up         Create Docker image for project\n"
        "  destroy    Destroy project's Docker image\n"
        "  run        Run command inside Docker container\n"
        "  script     Run script inside Docker container\n"
        "  shell      Run shell inside Docker container\n"
        "  status     Show project status\n")
    return

  ctx = Context(dir)

  command = args.pop(0)
  if command == "up":
    do_up(ctx, args)
  elif command == "destroy":
    do_destroy(ctx, args)
  elif command == "run":
    do_run(ctx, args)
  elif command == "script":
    do_script(ctx, args)
  elif command == "shell":
    do_shell(ctx, args)
  elif command == "status":
    do_status(ctx, args)
  else:
    raise RuntimeError("Unsupported command {}".format(command))

if __name__ == "__main__":
  main(os.getcwd(), list(sys.argv))
